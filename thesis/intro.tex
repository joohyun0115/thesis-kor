\section{개요} \label{sec:intro}

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Background
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
최근 프로세서의 코어 수가 증가됨에 따라, 공유 메모리 시스템이 멀티코어에서 매니코어로 변화되고 있다.
이처럼 코어 수가 증가되는 환경에서 시스템의 확장성(Scalability)은 매우 중요한 요소 중 하나이다.
시스템의 확장성 중에서도 운영체제 커널(Kernel)은 시스템 전체 성능에 영향을 주며, 
만약 운영체제 커널이 확장성이 없다면 커널의 서비스를 이용하는 응용프로그램도 확장성이 없게 된다.
이처럼 전체 시스템에서 중요한 역할을 하는 운영체제 커널 중 그동안 가장 많이 사용되고 연구되고 있는 것은 
리눅스 커널이다. 
그 이유는 최근까지도 리눅스 커널은 멀티코어 최적화에 많은 연구가 진행 되고 있기 때문이다. 
하지만 이렇게 멀티코어에 최적화된 리눅스 커널도 코어 수가 100코어 이상의 매니코어 
시스템에서는 여전히 확장성 문제를 가지고 있다~\cite{SilasBoydWickizer2010LinuxScales48}~\cite{Changwoo2016UMSF}.
확장성 문제 중 가장 큰 문제를 발생시키 것은 공유 데이터를 안전하게 보호하기 
위한 락(Lock)에 의한 직렬화 문제이다.
최근에는 락에 의한 직렬화 문제 뿐만 아니라, NUMA환경에서 발생하는 캐시 메모리의 일관성을 
유지하기 위한 캐시 일관성 트래픽 역시 많은 확장성 문제를
야기하고 있다고 보고있다\cite{mckenney2011parallel}~\cite{SilasBoydWickizerPth}.

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Problem general
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
이처럼 락에 의한 스레드들의 직렬화와 캐시 일관성 트래픽을 줄이기 위한 여러 방법들이 연구되고
있다.
예를 들어, 새로운 운영체제를 제안하는 연구, 기존 운영체제를 수정하는 연구, 확장성 있는 락에 대한 연구 
그리고 새로운 동기화 기법에 또는 확장성 있는 자료구조에 대한 연구들이 진행되고 있다.
그 중 동기화 기법에 대한 연구는 RCU와 같이 읽기 연산이 많은 자료구조(Read-mostly Data Structure)를 
대상으로 연구가 되어왔으며, 이것은 읽기 연산이 많은 상황에서는 굉장히 높은 성능과 확장성을 가지는 장점이 있다.
하지만 업데이트 연산이 많은 환경에서는 여전히 업데이트 락의 한계인 락에 의한 오버헤드와 스레드들의 
직렬화 문제가 생긴다. 
따라서 이러한 문제를 해결하기 위해, 여러 동시적 업데이트 방법들이 연구되고 있다.

동시적 업데이트 기법을 이용하여 업데이트 직렬화 문제를 해결하는 연구들은 
업데이트 비율에 따라 많은 성능 차이를 보이고 있다.
그 중 높은 업데이트 비율(Update-heavy)을 가진 자료 구조에서 기존 방법들은 대부분 효율적이지 않다.
그 이유는 업데이트 락 자체가 가진 캐시 일관성 트래픽 오버헤드가 있고, 업데이트 연산들은 읽기 연산과 
다르게 병렬로 수행되지 못하기 때문이다.
이러한 문제를 해결하기 위해 몇몇 연구들이 진행되었는데, 
높은 업데이트 비율을 가진 Update-heavy 자료구조에 대한 해결책 중 
하나는 락에 의한 캐시 일관성 트래픽 현상을 줄인 로그 기반(Log-based)
알고리즘~\cite{Hendler2010FC}~\cite{SilasBoydWickizerPth}을 사용하는 것이다.
로그 기반 알고리즘은 업데이트가 발생하면, 자료구조의 업데이트 연산을 
락 없이 퍼코어(Per-core) 또는 원자적(Atomic)으로 로그로 저장하고, 업데이트를 병렬로 수행하도록 하는 방법이다.
또한 읽기 연산을 수행하기 전에 저장된 로그를 반영하는 것이다.
결국 읽기 연산은 항상 최신 데이터를 읽게 되며, 이것은 마치 CoW(Copy on Write)와
유사한 방법이다~\cite{PaulDetailLWN}~\cite{Morrison2016SSM}.

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Problem 
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
\textit{S. Boyd-Wickizer외}는 동기화된 타임스탬프 카운터(Synchronized Timestamp
Counters)를 하드웨어 적으로 지원한다는 것을 가정하에, 업데이트 연산이 많은 Update-heavy 자료구조를 
대상으로 동시적 업데이트 문제를 해결하였다.
즉 모든 코어간 동기화된 타임스탬프와 퍼코어 로그를 활용하여 Update-heavy 자료구조를 대상으로 
동시적 업데이트가 가능하도록 만듦과 동시에 캐시 일관성 트래픽을 줄였다~\cite{SilasBoydWickizerPth}.
이러한 동기화된 타임스탬프 카운터 기반의 퍼코어 로그를 활용한 방법은
업데이트 부분만 고려했을 때, 퍼코어에 데이터를 저장함에 따라 굉장히 높은 확장성을 가질 수 있다.
하지만 NUMA 구조로 되어 있는 매니코어 시스템은 동기화된 전역 타임스탬프 카운터를 제공하지 
않는다. 
따라서, 하나의 \textit{Clock Source}를 공유하는 시스템에만 적용할 수 있는 문제를 가진다.
즉 일반적으로 서버 구조에서 많이 사용하고 있는 NUMA 구조로 구성된 매니코어 시스템은 소켓 단위로 
\textit{Clock Source}가 다르기 때문에 전역 타임스탬프가 존재하지 않는다. 
따라서 아직 검증되지 않는 소프트웨어 적인 동기화된 타임스탬프 카운터는 결국 \textit{Clock Skew}를 낳고, 
이것은 결국 저장된 업데이트 연산들의 순서가 바뀔 위험성을 가지고 있다.

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Method
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%
%We propose a novel lightweight log-based differed update method(\LDU) to
% achieve the maximum performance scalability for update-heavy data structures solving the 
%problems of sequential processing raised from the previous research:
%cache communication overhead in logging and time-stamp management cost during
% log ordering. 
%Such improved scalability could be achieved through combination of widely known 
%log-based concurrent update concept and our own way of efficient implementation
%methods of the log management scheme: log record slot reuse in the log queue
% and using minimal hardware-based synchronization
%method(compare and swap, test and set, atomic swap).
본 논문은 동기화된 타임스탬프 카운터를 사용하지 않는 공유 메모리 시스템을 위한 
로그 기반 지연 업데이트 방법인 LDU(Lightweight log-based Deferred Update)를 개발하였다.
LDU는 타임스탬프 카운터가 반드시 필요한 연산들을 하드웨어 동기화 기법을 이용하여 
로그가 발생하는 순간 제거하고, 불필요한 로그 제거하여 확장성을 향상 시키는 방법이다.
이로 인해 기존 하드웨어로 제공하지 않은 타임스탬프 카운터의 문제와 
캐시 일관성 트래픽 때문에 발생하는 병목 현상을 동시에 해결하였다.
즉 분산 시스템(Distributed Systems)에서 사용하는 로그 기반의 
동시적 업데이트 방식과 최소한의 공유 메모리 시스템의 하드웨어 기반 동기화(Hardware-based
Synchronization) 기법(Compare And Swap, Test And Set, Atomic Swap)을 조합하여 기존 동시적
업데이트 문제를 해결하였다.

이처럼 동기화된 타임스탬프 카운터를 제거함과 동시에, 캐시 일관성 트래픽의 병목 현상을 줄인
LDU는 기존 로그 기반 알고리즘들의 장점들을 포함할 뿐만 아니라 추가적인 장점을 가진다.
첫째, 업데이트가 수행하는 시점 즉 로그를 저장하는 순간에는 락이 필요가 없다.
따라서 락에 대한 오버헤드 없이 동시적 업데이트를 수행할 수 있다
둘째로, 저장된 업데이트 연산이 락과 함께 하나의 코어에서 수행하기 때문에, 
캐시 효율성이 높아질 수 있다\cite{Hendler2010FC}.
다음으로, 기존 여러 자료구조에 쉽게 적용할 수 있는 장점이 있다.
게다가 마지막으로, 로그를 저장하기 전에 저장된 로그를 삭제할 수 있으므로, 나중에 로그 병합에 
따른 오버헤드를 줄일 수 있다. 

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Result
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
우리는 이와 같은 장점을 가지는 LDU를 리눅스 커널에서 높은 업데이트 비율 때문에 성능 확장성 
문제를 야기하는 익명 역 매핑(Anonymous Reverse Mapping)과 파일 역 매핑(File Reverse Mapping) 자료구조에
적용하였다. 이를 통해 리눅스 커널의 성능 확장성을 향상 시켰다.
우리는 LDU를 리눅스 커널 버전 4.5-rc4에 구현하였고, 리눅스 \code{fork}가 많이 발생하는 워크로드인
AIM7~\cite{AIM7Benchmark}, MOSBENCH~\cite{MOSBENCH}의 Exim~\cite{Exim}, Lmbench~\cite{mcvoy1996lmbench}를 
대상으로 성능 개선을 보였다. 
수정 안한 리눅스 커널보다 120코어에서 각각 1.5배, 2.6배, 2.7배 성능 향상을 이루었다.

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Contribution 정리
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
\newpage
\section{논문의 기여}\label{sec:introcontri}
본 논문은 다음과 같은 기여를 하였다.
\begin{itemize}
\item 우리는 높은 업데이트 비율을 가지는 자료구조를 위한 새로운 로그 기반 동시적 업데이트
 방법인 LDU를 개발하였다.
LDU는 기존 연구에서 사용한 동기화된 타임스탬프 카운터를 제거하였고, 이를 위해 
타임스탬프가 필요한 최소한의 연산을 하드웨어 동기화 기법을 사용하여 삭제하였다.
따라서, 동시적 업데이트를 뿐만 아니라 캐시 일관성 트래픽을 최소화 하였다.
\item 
우리는 LDU을 매니코어 시스템인 인텔 제온 120 코어 시스템 위에 동작하는 리눅스 커널의 
2가지 역 매핑 (익명, 파일)에 적용하여, 리눅스 \code{fork}의 성능 확장성 문제를 해결하였다.
LDU에 의해 \code{fork} 관련 벤치마크 성능은 워크로드 특성에 따라 1.5배 부터 2.7배 까지 향상된다.
\end{itemize}


\newpage
\section{논문 구성} \label{sec:intro}
본 논문의 구성은 다음과 같다.

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Mapping
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
~\ref{sec:related}장에서는 관련 연구와 배경 지식에 대해서 설명한다.
~\ref{sec:problem}장에서는 확장성 문제점에 대해서 기술한다. 
~\ref{sec:ldu}에서는 LDU 설계에 대한 내용과 LDU의 알고리즘에 대해서 설명하며,
~\ref{sec:linux}장에서는 LDU를 리눅스 커널에 어떻게 적용 하였는지를 설명한다.
~\ref{sec:evaluation}장에서는 본 논문에서 제안한 방법에 대한 실험 결과에 대해서 설명한다. 
마지막으로 ~\ref{sec:concl}장에서는 본 논문의 결론과 향후 연구에 대해서 기술한다. 

