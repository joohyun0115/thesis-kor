\section{개요} \label{sec:intro}

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Background
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
최근 프로세서의 코어 수가 증가함에 따라, 공유 메모리 시스템이 멀티코어에서 매니코어로 변화되고 있다.
이처럼 코어가 증가하는 환경에서 시스템의 확장성(Scalability)은 매우 중요한 요소 중 하나이다.
시스템의 확장성 중에서도 운영체제 커널(Kernel)은 시스템 전체 성능에 영향을 준다.
그 이유는 만약 운영체제 커널이 확장성이 없다면 커널을 이용하는 응용프로그램도 역시 확장성이 없기 때문이다.
이처럼 전체 시스템에서 중요한 역활을 하는 운영체제 커널 중 가장 많이 사용되고 연구되고 있는 것은 리눅스 커널이다. 
그 이유는 최근까지도 리눅스 커널은 멀티코어 최적화에 많은 연구가 되고 있기 때문이다. 
하지만 이렇게 멀티코어에 최적화된 리눅스 커널도 코어 수가 100코어 이상으로 증가하는 
매니코어 시스템에서는 여전히 확장성 문제를 가지고 있다~\cite{SilasBoydWickizer2010LinuxScales48}~\cite{Changwoo2016UMSF}.
그 동안 확장성 문제 중 가장 큰 문제를 발생하는 것이 공유 데이터를 안전하게 보호하기 
위한 락(Lock)에 의한 직렬화 문제였으나,
최근에는 락에 의한 직렬화 문제 뿐만 아니라, NUMA환경에서 발생하는 캐시 메모리의 일관성을 
유지하기 위한 캐시 일관성 트래픽 역시 많은 확장성 문제를
야기하고 있다\cite{mckenney2011parallel}~\cite{SilasBoydWickizerPth}.

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Problem general
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
이처럼 락에 의한 스레드들의 직렬화와 캐시 일관성 트래픽을 줄이기 위한 여러 방법들이 연구되고
있다.
이러한 문제들를 해결하기 위핸 새로운 운영체제를 제안하는 연구와 
기존 운영체제를 수정하는 연구, 확장성 있는 락에 대한 연구 그리고 새로운 동기화 기법에 
또는 확장성 있는 자료구조에 대한 연구들이 진행되고 있다.
그 중 동기화 기법에 대한 연구는 그 동안 RCU와 같이 읽기 연산이 많은 자료구조(Read-mostly Data Structure)를 
대상으로 연구가 되어왔으며, 읽기 연산이 많은 상황에서는 굉장히 높은 성능과 확장성을 가지게 되었다. 
하지만 업데이트 연산이 많은 환경에서는 여전히 업데이트 락의 한계인 
락에 의한 오버헤드와 함께 스레드들이 직렬화 되어 문제가 생긴다.  
따라서 이러한 문제를 해결하기 위해 여러 동시적 업데이트 방법들이 연구되고 있다.

이러한 동시적 업데이트 방법을 사용하여 업데이트 직렬화 문제를 해결하는 연구들은 
업데이트 비율에 따라 많은 성능 차이를 보인다.
그 동안 연구된 방법들은 모두 높은 업데이트 비율(Update-heavy)을 가진 자료 구조 때문에 발생하는 
확장성 문제에 대해서는 여전히 효율적이지 않다.
그 이유는 업데이트 락 자체가 가진 캐시 일관성 트래픽 오버헤드가 있고, 업데이트 연산들은 읽기 연산과 
다르게 병렬로 수행되지 못하기 때문이다.
따라서 높은 업데이트 비율을 가진 Update-heavy 자료구조에 대한 해결책 중 하나는 락에 의한 캐시 일관성 트래픽 
현상을 줄인 로그 기반(Log-based) 알고리즘~\cite{Hendler2010FC}~\cite{SilasBoydWickizerPth}을
사용하는 것이다.
로그 기반 알고리즘은 업데이트가 발생하면, 자료구조의 업데이트 연산을 
락 없이 퍼코어(Per-core) 또는 원자적(Atomic)으로 로그로 저장하고
읽기 연산을 수행하기 전에 저장된 로그를 반영하는 것이다.
결국, 읽기 연산은 항상 최신 데이터를 읽게 되며, 이것은 마치 CoW(Copy on Write)와
유사한 방법이다~\cite{PaulDetailLWN}~\cite{Morrison2016SSM}.

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Problem 
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
S. Boyd-Wickizer \textit{et al.}는 동기화된 타임스탬프 카운터(Synchronized Timestamp
Counters)를 하드웨어적으로 지원한다는 것을 가정으로 업데이트 연산이 많은 Update-heavy 자료구조를 
대상으로 문제를 해결하였다.
즉 모든 코어간 동기화된 타임스탬프와 퍼코어 로그를 활용하여 Update-heavy 자료구조를 대상으로 
동시적 업데이트가 가능하도록 만듦과 동시에 캐시 일관성 트래픽을 줄였다~\cite{SilasBoydWickizerPth}.
이러한 동기화된 타임스탬프 카운터 기반의 퍼코어 로그를 활용한 방법은
업데이트 부분만 고려했을 때, 퍼코어에 데이터를 저장함에 따라 굉장히 높은 확장성을 가진다.
하지만 이러한 방법은 일반 NUMA 구조로 되어 있는 매니코어 시스템에는 
하드웨어적인 시스템에 동기화된 타임스탬프 카운터가 없으므로 특정 시스템만 적용할 수 있는 문제를 가진다. 
즉 서버 구조에서 많이 사용하고 있는 NUMA 구조로 구성된 매니코어 시스템은 소켓 단위로 Clock Source가 
틀리기 때문에 전역 타임 스템프가 존재하지 않는다. 
따라서 아직 검증되지 않는 소프트웨어적인 동기화된 타임스탬프 카운터는 Clock Skew등을 낳고, 
이것은 결국 저장된 명령어의 순서가 바뀔 위험성을 가지고 있다.

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Method
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%
%We propose a novel lightweight log-based differed update method(\LDU) to
% achieve the maximum performance scalability for update-heavy data structures solving the 
%problems of sequential processing raised from the previous research:
%cache communication overhead in logging and time-stamp management cost during
% log ordering. 
%Such improved scalability could be achieved through combination of widely known 
%log-based concurrent update concept and our own way of efficient implementation
%methods of the log management scheme: log record slot reuse in the log queue
% and using minimal hardware-based synchronization
%method(compare and swap, test and set, atomic swap).
본 논문은 이러한 문제가 있는 동기화된 타임스탬프 카운터를 사용하지 않고,
공유 메모리 시스템을 위한 새로운 LDU(Lightweight log-based Deferred Update)를 개발하였다.
LDU는 타임스탬프 카운터가 반드시 필요한 연산들은 하드웨어 동기화 기법을 이용하여 
로그를 업데이트 순간 제거하고, 불필요한 로그 제거하여 확장성을 향상시키는 방법이다.
이로 인해 기존 하드웨어적으로 제공하지 않는 동기화된 타임스탬프 카운터의 문제와 
캐시 일관성 트래픽 때문에 발생하는 병목현상에 대한 문제를 동시에 해결하였다.
해결 방법은 분산 시스템(Distributed Systems)에서 사용하는 로그 기반의 
동시적 업데이트 방식과 최소한의 공유 메모리 시스템의 하드웨어 기반 동기화(Hardware-based
Synchronization) 기법(Compare And Swap, Test And Set, Atomic Swap)을 조합하여 동시적 업데이트
문제를 해결하였다.

이처럼 동기화된 타임스탬프 카운터를 제거함과 동시에, 캐시 일관성 트래픽의 병목 현상을 줄인
LDU는 기존 로그 기반 알고리즘들의 장점들을 모두 포함할 뿐만 아니라 추가적인 장점을 가진다.
첫째로, 업데이트가 수행하는 시점 즉 로그를 저장하는 순간에는 락이 필요가 없다.
따라서 락의 오버헤드 없이 동시적 업데이트를 수행할 수 있다
둘째로, 저장된 업데이트 연산의 로그를 락과 함께 하나의 코어에서 수행하기 때문에, 
캐시 효율성이 높아진다~\cite{Hendler2010FC}.
다음으로, 기존 여러 자료구조에 쉽게 적용할 수 있는 장점이 있다.
게다가 마지막으로, 로그를 저장하기 전에 삭제하므로 나중에 로그 병합에 따른 오버헤드를 
줄일 수 있다. 

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Result
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
우리는 위와 같은 장점을 가지는 LDU를 리눅스 커널에서 높은 업데이트 비율 때문에 성능 확장성 
문제를 야기하는 익명 역 매핑(Anonymous Reverse Mapping)과 파일 역 매핑(File Reverse Mapping)에
적용하여 확장성을 향상 시켰다.
우리는 LDU를 리눅스 커널 버전 4.5-rc4에 구현하였고, 리눅스 \code{fork}가 많이 발생하는 워크로드인
AIM7~\cite{AIM7Benchmark}, MOSBENCH~\cite{MOSBENCH}의 Exim~\cite{Exim}, Lmbench~\cite{mcvoy1996lmbench}를 
대상으로 성능 개선을 보였다.
개선은 수정안한 리눅스 커널보다 120코어에서 각각 1.5x, 2.6x, 2.7x 성능 향상을 이루었다.

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Contribution 정리
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
\newpage
\section{논문의 기여}\label{sec:introcontri}
본 논문은 다음과 같은 기여를 하였다.
\begin{itemize}
\item 우리는 높은 업데이트 비율를 가지는 자료구조를 위한 새로운 로그 기반 동시적 업데이트
 방법인 LDU를 개발하였다.
LDU는 로그 기반 업데이트와 함께 하드웨어적으로 동기화된 타임스탬프 카운터가 존재하지 않는 문제를 
타임스탬프가 필요한 최소한의 연산을 하드웨어 동기화 기법을 사용하여 삭제하는 방법이다.
따라서, 캐시-일관성 트래픽을 최소화 하였다.
이와 같이 최소한의 하드웨어 동기화 기법을 사용한 LDU는 로그를 업데이트 순간 지우고, 
로그를 효율적으로 활용하는 방법이다.  
\item 
우리는 LDU을 매니코어 시스템인 인텔 제온 120 코어 스스템 위에 동작하는 리눅스 커널의 
2가지 역 매핑 (익명, 파일)에 적용하여, 리눅스 \code{fork}의 성능 확장성 문제를 해결하였다.
\code{fork} 관련 벤치마크 성능은 워크로드 특성에 따라 1.6x부터 2.2x까지 향상된다.
\end{itemize}


\newpage
\section{논문 구성} \label{sec:intro}
본 논문의 구성은 다음과 같다.

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Mapping
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
~\ref{sec:related}장에서는 관련 연구와 배경지식에 대해서 설명한다.
~\ref{sec:problem}장에서는 리눅스 확장서의 문제점에 대해서 기술한다. 
~\ref{sec:ldu}에서는 LDU 설계에 대한 내용과 LDU의 알고리즘에 대해서 설명하며,
~\ref{sec:linux}장에서는 LDU를 리눅스 커널에 어떻게 적용하였는지를 설명한다.
~\ref{sec:evaluation}장에서는 본 논문에서 제안한 방법에 대한 실험 결과에 대해서 설명한다. 
마지막으로 ~\ref{sec:concl}장에서는 본 논문의 결론과 향후 연구에 대해서 기술한다. 

