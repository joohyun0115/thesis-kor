\section{Introduction} \label{sec:intro}

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Background
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
\ifkor
\else
\fi
Achieving performance scalability has been a most important factor in 
highly parallel systems with many cores (e.g., over 100 cores).
The performance scalability of a whole system is naturally limited by 
scalability of underlying operating system kernel; Linux kernel has been 
widely considered in ordinary systems.
Previous research revealed that Linux kernel has significant problems limiting
performance scalability in many core systems~\cite{SilasBoydWickizer2010LinuxScales48}~\cite{Changwoo2016UMSF}
and the major sources of the problems are update lock contention in a few
kernel data structures~\cite{mckenney2011parallel}~\cite{Matveev2015RLU}.

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Problem general
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
Early research accomplishments regarding the update serialization problems
include a number of concurrent
update methods~\cite{Arbel2014ConcurrentRCU}~\cite{Matveev2015RLU}~\cite{Dodds2015SCT}.
Such research provides bases to solve the update serialization problems, but
does not effectively handle serious scalability bottleneck for update-heavy data structures.
Log-based algorithms~\cite{Hendler2010FC}~\cite{SilasBoydWickizerPth}
have been proposed to solve this update serialization problem by reducing cache coherence-related
overheads for update-heavy data structures.
When update operations occur, log-based algorithm logs the update
operation and applies all operation logs to the data structure
before read operation, so readers can read up to date data structure in a way
similar to CoW(Copy On Write)~\cite{PaulDetailLWN}~\cite{Morrison2016SSM}.

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Problem 
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
Among the log-based methods,
S. Boyd-Wickizer \textit{et al.} proposed OpLog~\cite{SilasBoydWickizerPth}, where 
each update operation generates a log with synchronized time-stamp counters
and serialization of the logs based on the time-stamps solves the scalability
bottleneck for update-heavy data structures: 
the loggings are performed on to per-core memory instead of shared memory and
thus eliminates cache communication overhead.
However, the OpLog still has problems in scalability since the synchronized time-stamp
counters necessitates time-stamp merging and ordering processes leading to 
performance scalability problems in high CPU core counts.

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Method
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%
We propose a novel lightweight log-based differed update method(\LDU) to achieve 
the maximum performance scalability for update-heavy data structures solving the 
problems of sequential processing raised from the previous research:
cache communication overhead in logging and time-stamp management cost during log
ordering. 
Such improved scalability could be achieved through combination of widely known 
log-based concurrent update concept and our own way of efficient implementation
methods of the log management scheme: log record slot reuse in the log queue and 
using minimal hardware-based synchronization
method(compare and swap, test and set, atomic swap).

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Result
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

To evaluate our approach, we applied the \LDU to Linux kernel reverse
page mappings(anonymous page mapping, file page mapping) that are considered as
the major sources of limiting performance scalability due to their 
update-heavy characteristics.
We implemented the \LDU in a Linux 4.5-rc6.
We evaluated the performance and scalability using a fork-intensive workload-
AIM7~\cite{AIM7Benchmark}, Exim~\cite{Exim} from MOSBENCH~\cite{MOSBENCH}
and Lmbench~\cite{mcvoy1996lmbench}-our design improves throughput and execution
time on 120 core by 1.5x, 2.6x, 2.7x respectively, relative to stock Linux.

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Contribution 정리
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\textbf{Contributions.} Our research makes the following contributions:
\begin{itemize}
\item We have developed a novel lightweight log-based deferred update method
eliminating the sources of limiting performance scalability in update-heavy data
structures with efficient log management implementation.
\item 
We applied the \LDU in Linux kernel to two reverse mapping(anonymous, file) on
an 120 core system to reduce fork scalability bottleneck.
Our design improved throughput and execution time from 1.5x through 2.7x on 120 core.
\end{itemize}

%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Mapping
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
The rest of this paper is organized as follows.
Section~\ref{sec:bg} describes the background and the Linux scalability problem.
Section~\ref{sec:ldu} describes the design of the \LDU algorithm and 
Section~\ref{sec:linux} explains how to apply the \LDU to Linux kernel, and
Section~\ref{sec:evaluation} shows the results of the experimental evaluation. 
Section~\ref{sec:related} describes related work with our research.
Finally, section~\ref{sec:concl} concludes the paper.
