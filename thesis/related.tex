\section{병렬화 운영체제 역사}
%20년의 프로세서들은 단일프로세서(uniprocessor) 디자인을 가졌고, 병렬처리와 락은 필요가 없었다. 
%Goal of an OS interface
%Make application developer's job easy
%Allow sharing
%File system, buffer cache, load balancing, etc.
%But, perfectly scalable Efficient implementation

%Three types of parallelism in operating systems
%1. User parallelism
%Users working concurrently with computer
%2. I/O concurrency
%Overlap computation with I/O to keep a processor busy
%3. Multiprocessors parallelism
%Exploit several processors to speedup tasks
%The first two may involve only 1 processor

%This talk: 4 phases in OS parallelism
%Time sharing
%Client/server
%SMPs
%Multicore 60s/70s
%80s/90s
%90s/2000s
%2005s-now Introduction of many ideas for parallelism
%I/O concurrency inside servers
%Multiprocessor kernels and servers
%All software parallel

%POSIX is just the wrong interface
%Shared data fundamentally limits scalability
%Kernels are too big/complex to fix
%Designs cannot keep up with core count

본 장에서는 현시점에서 운영체제 병렬화가 필요한 이유와 함께 운영체제의 병렬화의 역사에 관해서 설명한다.
그동안 운영체제의 병렬화는 시분활 시스템, 클라이언트(client) 서버(server) 구조, 그리고 SMPs(Shared Memory
Processor) 그리고 최근 프로세서에 코어가 많아 지는 멀티코어로 총 4단계에 거처 발전해 왔다~\cite{Kaashoek2015PCO}.

첫 번째 단계에서는 시분활 시스템에서 사용되는 병렬화이다. 
60년대 부터 70년대에서의 운영체제 병렬성은 시분할(time sharing) 시스템을 가졌다.
즉 컴퓨터 한대에 여러 사용자가 동시에 사용되었고, 대부분이 1개의 프로세서로 이루어졌다.
이 시점에서 병렬 처리 연구는 I/O 병렬화 프로그램에 대한 연구가 진행되었다~\cite{Bloch1959EDS}[CTSS 1962]. 
최대한 프로세서를 이용률(utilization)를 높여서 I/O를 처리하기 위해 즉 커널은
 병렬로 I/O를 처리하기 위해 다른 프로그램 커널로 문맥교환되어 실행되도록 만들었다.
 
%Example: the THE operating system [EWD123 1965, SOSP 1967]
%~\cite{Dijkstra1965CSP}
%Technische Hogeschool Eindhoven (THE)
%OS organized as many “sequential” processes
%I A driver is a sequential process
%The THE solution: semaphores

초기 컴퓨터 중 일부 프로세서들은 시분활 시스템과 멀티프로세서의 병렬화를 고려하여
 만들었다(예를 들어, 버로우스(Burroughs)의 B5000~\cite{Mayer1982ABB}).
따라서, 병렬화에 대해서 많은 관심과 노력이 이루어졌다.
그 결과 병렬화 관련 초기 많은 이론인 암달의 법칙~\cite{Amdahl1967VSP}, 멀틱스(Multics)에서의 트래픽 컨트롤
~\cite{Saltzer1966TCM}, 데드락 발견(deadlock detection) 그리고 락 오더링(locking ordering)등
많은 이론들이 생겨나게 되었다. 
70년대 하나의 프로세서 위에서 병렬화를 제공하기 위해 많은 연구 및 개발이 이루어졌고, 실제 
단일 프로세스에 여러 유저에게 시분활 기능으로
 병렬화를 제공하는 Unix 커널~\cite{Ritchie1973UTS}이 개발되었다.

두번째 단계에서는 80년대와 90년대에는 컴퓨터의 가격이 개인이 구매가 가능할 정도 내려갔으며,
 로컬 네트워크로 여러 유저가 
협업하면서 작업할 수 있는 환경이 되어 클라인트 서버 환경을 위한 병렬화가 이루어졌다.
문제는 여러 유저가 수행할 서비스(services)에 대한 병렬화가 필요하게 되었고, 
따라서 논커널 프로그래머들도 커널의 기능이 필요하여, 서버의 커널이 인터페이스(interface)를
 추가하여 유저들에게 병렬화 서비스를 제공하였다. 
 
그 결과 많은 운영체제 병렬화 기술들이 이 시점에 연구 개발되었다. 
예를 들어 스레드(Thread), 락(Locks) 그리고 컨디션 변수(Condition variables)등 이 시점에 많은 연구가 
이루어졌다.
이벤트(events)와 스레드(threads)에 대한 논쟁~\cite{Ous96}~\cite{vonBehren2003WEB}
그리고 Accent~\cite{Rashid1981ACO},
Mach~\cite{Accetta86mach} , V~\cite{Cheriton1983DVK} 등 새로운 운영체제들이 제안되었다. 
이러한 연구들은 마이크로커널(microkernel)에 영감을 주었고, 결국 최근 많은 운영체제가 사용하고 있는 
Pthreads[POSIX.1c, Threads extensions (IEEE Std 1003.1c-1995)]에 대해 영향을 주었다. 
새로운 운영체제 뿐만 아니라 새로운 언어들(예를들어 Mesa~\cite{Lampson1979EPM})도
 연구되었고, 결국 가비지 컬렉션등에 대한 연구가 같이 진행되어, 그 결과 것들이 최근 자바(JAVA)와 고(Go) 언어등에
 영감을 주었다.
결론으로 커널의 인터페이스를 서버 개발자에게 노출하여 서버를 병렬로 이용 할 수 있게 만들었다.


\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\textwidth]{fig/shared_memory}
    \caption{90년대 공유 메모리 시스템}
  \label{shared_memory}
\end{figure}




다음 단계에서는 90년대 각각의 프로세서가 메모리를 공유하는 개념의 컴퓨터인 SMP(Shared-memory Multi
Pocessors)가 낮은 가격으로 보급이 되어서, 커널 또는 서버 개발자는 이 떄부터 심각하게 운영체제 병렬화에 대해서 고려하게 되었다.
예를 들어, 운영체제 커널은 BKL(Big Kernel Lock) 등을 지원하며 병렬화 기능을 제공하기 시작하였다.
이 시점 많은 회사(BBN Butterfly, Sequent, SGI, Sun, Thinking Machines 등)가 운영체제 병렬화에 대해서 
연구하기 시작했다.
그 결과 많은 운영체제 성능 확장성에 대해서 새로운 개념 예를들어, 
MCS 락~\cite{MellorCrummey1991MCS}, 유저 레벨 쓰레딩~\cite{Marsh1991FUT},
 NUMA 메모리 관리~\cite{Bolosky1991NPR}, 가상 머신 모니터(virtual machines monitor)
~\cite{Bugnion1997DRC} 등이 제안되었다.  


\begin{figure}[h]
  \begin{center}
    \includegraphics[scale=0.3]{fig/cpu}
  \end{center}
  \caption{CPU 발전 동향.}
  \label{fig:aim7}
\end{figure}

마지막 단계는 멀티코어이다.
그림 ~\ref{fig:aim7}과 같이 주파수는 계속 증가하다가, 2000년대 중반 멈추고, 그
때부터 코어수가 증가하고 있다. 
따라서 코어수가 100개 이상의 멀티코어 프로세서들도 등장함에 따라, 공유 때문에 야기하는 
새로운 문제가 발생하기 시작하였다.


\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{fig/archcache}
    \caption{공유 메모리 시스템}
  \label{shared_memory}
\end{figure}

 
최근에 발생하는 문제들은 상당 부분이 캐시라인(cache-line)의 공유 때문에 발생하는 문제이고, 
이를 해결하기 위해서 최근에는 여러 운영체제(section~\ref{sec:osrelated}),
 락 기법(section~\ref{sec:lockrelated}), 그리고 자료구조와
 알고리즘(section~\ref{sec:datarelated})들이 개발되고 있다.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\textwidth]{fig/archcache_percore}
    \caption{공유 메모리 시스템}
  \label{shared_memory}
\end{figure}

20년동안 싱글코어를 대상으로 연구가 되었고, 최근에는 이러한 문제를 해결하기 위해 
파티션닝 기법을 활용하여, 파티션닝 기법의 한 예로서는, 그림 x-x와 같이 공유되는 
전역 자료 구조를 각자 CPU에서 처리하도록 하는 방법이 있다.  
이러한 방법은 시스템 전반에 발생하는 캐시 커뮤니케이션 오버헤드를 줄일 수 있다. 

\input{related_os}
\input{related_lock}
\input{related_struct}
%\input{related_hw}



