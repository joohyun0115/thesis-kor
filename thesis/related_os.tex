%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
%Paragraph 1:Linux Scalability의 연구에 대한 설명
%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

\newpage
\section{최근 운영체제 병렬화 연구}
\label{sec:osrelated}

%To improve the scalability, researchers have attempted to create new
%operating systems~\cite{Boyd-WickizerCorey}~\cite{Wentzlaff2010fOS}
%~\cite{Baumann2009Barrelfish}~\cite{Zellweger2014Multikernel}
%~\cite{Liu2009Tessellation}~\cite{Farrington2010Helios}
%or have
% attempted to optimize existing operating
%
 % systems~\cite{SilasBoydWickizer2010LinuxScales48}~\cite{AustinTClements2012RCUBalancedTrees}~\cite{Clements2013RadixVM}~\cite{SilasBoydWickizerPth} ~\cite{Changwoo2016UMSF}.
 
코어 수가 증가되는 상황에서 병렬화가 중요해진 운영체제에 대한 연구는 성능에
 대한 확장성을 향상시키기 위해서, 새로운 확장성 있는
운영 체제를 만들거나 ~\cite{Boyd-WickizerCorey}~\cite{Wentzlaff2010fOS}
~\cite{Baumann2009Barrelfish}~\cite{Zellweger2014Multikernel}
~\cite{Liu2009Tessellation}~\cite{Farrington2010Helios} 
기존 운영체제를 최적화 시키는
방법~\cite{SilasBoydWickizer2010LinuxScales48}
~\cite{AustinTClements2012RCUBalancedTrees}~\cite{Clements2013RadixVM}~\cite{SilasBoydWickizerPth}을
시도하고 있다.



\subsection{새로운 운영체제 제안}

%Our research belongs to optimizing existing operating systems in order to
%solve the Linux fork scalability problem.
%이 중 우리의 연구는 리눅스의 fork에 대한 확장성을 개선하기 위한
% 기존 운영체제를 최적화 하는 방법에 속한다. 
%However, previous research did not deal with the anonymous reverse mapping,
%which is one of the fork scalability bottleneck.
%하지만 기존 연구들은 fork의 확장성 병목 지점 중 하나인 익명 역 매핑에 대해서는 처리하지 않았다.

%Cache-line fetches are expensive
%Read cache line written by
%another core: expensive!
%100–10000 cycles
%(contention)

%For reference, a creat system call costs 2.5K cycles
%Avoiding cache-line sharing is challenging
%Consider read-write lock
%struct readwritelock {
%int count;
%// -1, write mode; > 0, read mode
%listhead waiters;
%%spinlock waitlock;
%}
%Problem: to acquire lock in read mode requires modifying count
%%Fetching a remote cache line is expensive
%Many readers can cause performance collapse

\subsubsection{Corey}

Corey는 MIT의 Parallel and Distributed Operating Systems Group에서 개발하였다. 
기본적인 철학은 커널 영역의 공유 데이터를 유저 응용프로그램이 사용할 수 있게 만들어 주어서, 
공유 데이터 때문에 발생하는 경합 문제를 유저에게 해결할 수 있도록 제공하는 것이다. 
따라서 유저 응용프로그램의 워크로드에 따라 경유 문제를 해결할 수 있는 방향을 제공해준다.
이것은 exokernel[]의 개념을 가져와서 매니코어 시스템에 적용하였고, 이를 통해 성능 확장성을 개선하였다.

이러한 Corey는 3가지 기본적은 개념을 가지고 있다. 그것은 공유(shares), 주소 트리(address trees)과 커널
코어(kernel core)이다.
공유는 어떻게 커널 자료구조를 접근할 수 있는지에 대해서 제공해준다.

%Corey[7] 연구팀은 기존 운영체제에서 공유가 필요는 내부 데이터까지 코어 간 자동 공유하게 함으로써
%(이로 인해 프로세서 내의 코어 간에 캐쉬 일관성 작업
%이 빈번해 짐) 시스템의 성능이 저하되는 문제점에 주목
%하고 있다. 이는 기존 운영체제가 응용의 사용 패턴에
%상관 없이 데이터가 코어 간에 공유되고 하드웨어 역시
%응용의 패턴에 상관 없이 동기화하는 방식이기에 성능
%하락을 피할 수 없다는 것이다.
%현재의 대부분 운영체제는 응용을 위해 기능을 추상 화하고 추상화된 기능을 사용하기 위해 시스템 콜 인터


\subsubsection{Barrelfish}

Barrelfish 운영체제는 취히리의 ETH와 마이크로 소프트(Microsoft)가 공동연구하여 만든 운영체제이다. 
또는 멀티커널(multikernel)이라고도 부른다.
기본적인 철한은 공유 메모리 시스템 기능들을 모두 분산 처리 방식으로 구현하자는 것이다.


\subsubsection{fOS}

fOS(Factored operating system)은 역시 Massachusetts Instiute of Technoloy에서 개발한
Corey와 비슷한 개념의 운영체제이다. 
fOS의 5가지의 설계 철학을 가지고 있다. 

\subsubsection{Fused OS}

Tesselation 운영체제는 버클리에서 만든 클라인어트 운영체제이다.
이것이 기본철학은 시간과 공간을 파티션하여 동작시키도록 만든 하나의 파티션닝 운영체제이다.

IBM 왓슨 연구소에서 모노리틱 구조의 운영체제와
마이크로 커널 구조의 운영체제의 장점을 혼합한 구조
의 운영체제(Fused OS)를 연구[12][13]하였다. IBM
Blue Gene/Q 시스템에서 HPC 응용을 성능 확장성이
있고 신뢰성 있게 수행시키는 것이 주목적이지만, 이질
적인(heterogeneous) 코어로 구성된 Manycore 시스템
의 운영체제 구조 연구가 시작점이었다. 여기서 이질적
인 코어란 전력 효율적인 코어(PEC: Power Efficient
Core)와 단일 쓰레드에 성능 최적화된 코어(STOC:
Single Thread Optimized Core)로 구성된 프로세스 코
어 칩을 의미한다. 따라서 Fused OS 설계개념은 응용과
운영체제를 다른 코어에서 수행되도록 하여 응용의 성
능이 운영체제에 의해 간섭을 받지 않도록 하는 것이다.


같이 Fused OS의 기본 동작은 응용과 운
영체제가 다른 코어에서 각각 수행되는 것이다.
를 저장하고 리눅스 운영체제에게 전달하는 역할을 한
다. 반면에 리눅스 운영체제는 기존의 리눅스 코드에
PEC 코어의 메모리 등을 접근할 수 있는 기능을 추가하
였다. 게다가 PEC 코어를 관리하는 CL(Compute
Library)이 리눅스 응용으로 동작하며, 이 CL은 가벼운
커널 기능을 가지고 있게 설계되었다. 즉 리눅스 운영체
제에서 만들어진 응용이 PEC 코어에서 수행되기 위해
서, CL는 PEC 메모리에 응용 이미지를 구축하고 수행
되도록 PEC 코어에 전달하게 된다. 따라서 Fused OS는
코어와 메모리 자원을 분할하여, HPC 응용의 성능을 보
장하면서 리눅스 운영체제 기능도 제공하게 되었다.
HPC 벤치마킹 결과, Fused OS는 운영체제 기능을
하는 코어와 계산을 위한 코어를 분리시켰기 때문에, 성
능 측면에서 계산을 위한 코어에서 실행되는 응용은 운
영체제 기능을 하는 코어에서 실행하는 응용보다 우수
하다는 것을 밝혔다. 하지만 응용에서 호출하는 시스템
호출은 원격의 운영체제 코어에서 처리되기 때문에 추
가적인 호출시간이 필요하다.



\subsubsection{Barrelfish/DC}

Barrelfish/DC는


\subsection{기존 운영체제 최적화}

\subsubsection{Linux scalability}

OpLog는 RCU와 반대로 업데이트 비율이 높은 업데이트 헤비(Update heavy)한 자료구조를 위해 만든 
동기화 기법 중 하나이다.



\subsubsection{BonsaiVM}
BonaiVM은 MIT Parallel and Distributed Operating Systems Group에서 개발한 리눅스 커널을 위한 
가상 메모리 시스템이다. 
RCU라는 리눅스 커널의 동기화 기법을 활용한 방법 중 하나이다.
이것은 새로운 운영체제를 제안하는 것이 아니라, 리눅스 커널을 대상으로 개선한 연구이며, 
리눅스 커널 중 가상 메모리 시스템을, RCU라는 동기화 기법을 사용하여 성능 확장성을 향상시킨 연구이다.



\subsubsection{RadixVM}

RadixVM은 기존 SV6 운영체제에 대해서 가상 메모리에 대한 부분을 성능 확장성 있게 만든 연구이다.
리눅스는 너무 복잡한 구현으로 인하여, 적용하기 힘은 개념을 덜 복잡한 운영체제에 적용하였다. 




\subsubsection{SC rule}




%BonsaiVM~\cite{AustinTClements2012RCUBalancedTrees} solved this address space
%problem by using the RCU;
%RadixVM~\cite{Clements2013RadixVM} created a new VM using refcache and radix
%tree, which enable \code{munmap}, \code{mmap}, and \code{page fault} on
%non-overlapping memory regions to scale perfectly.
%Alternatively, to avoid contention caused by shared address space locking,
%system programmers change their multithreaded applications to use
%processes~\cite{SilasBoydWickizer2010LinuxScales48}.

